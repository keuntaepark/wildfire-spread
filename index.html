<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <title>ì‚°ë¶ˆ í™•ì‚° ì˜ˆì¸¡</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- ë¡œì»¬ Leaflet CSS -->
    <link rel="stylesheet" href="./leaflet/leaflet.css" />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
      }
      body {
        background-color: #f4f4f4;
        color: #333;
      }
      header {
        background: #fff;
        padding: 8px 16px;
        border-bottom: 1px solid #ccc;
        position: relative;
      }
      header h2 {
        font-size: 18px;
        margin: 0;
      }
      header p {
        font-size: 13px;
        margin: 4px 0 0;
        color: #666;
      }
      #map {
        width: 100%;
        height: calc(100vh - 90px);
      }
      #searchBox {
        position: absolute;
        top: 70px;
        left: 10px;
        z-index: 9999;
        width: 220px;
        background: #fff;
        border-radius: 6px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
        padding: 8px;
        border: 1px solid #eee;
      }
      #searchBox label {
        font-size: 14px;
        font-weight: 600;
        margin-bottom: 6px;
        display: block;
      }
      #searchBox input {
        width: 100%;
        padding: 6px;
        font-size: 14px;
        margin-bottom: 8px;
        border: 1px solid #ccc;
        border-radius: 4px;
      }
      #searchBox button {
        width: 100%;
        padding: 8px;
        margin-bottom: 6px;
        font-size: 14px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        background: #ff6b6b;
        color: #fff;
      }
      #searchBox button:hover {
        background: #ff4c4c;
      }
      #infoBox {
        position: absolute;
        bottom: 10px;
        right: 10px;
        z-index: 9999;
        width: 200px;
        background: #fff;
        border-radius: 6px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
        padding: 8px;
        border: 1px solid #eee;
        font-size: 13px;
        line-height: 1.3;
        white-space: pre-wrap;
      }
      #infoBox h3 {
        margin-bottom: 4px;
        font-size: 14px;
        font-weight: 600;
      }
      #refreshBtn {
        display: block;
        width: 100%;
        margin-top: 8px;
        padding: 6px;
        font-size: 12px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        background: #777;
        color: #fff;
        text-align: center;
      }
      #refreshBtn:hover {
        background: #555;
      }
      /* Legend ìŠ¤íƒ€ì¼ */
      .legend {
        line-height: 18px;
        color: #555;
      }
      .legend i {
        width: 18px;
        height: 18px;
        float: left;
        margin-right: 8px;
        opacity: 0.8;
      }
      /* ëª¨ë“  ì…€ì— ê·¸ë¦¼ì íš¨ê³¼ ì ìš© */
      .highProbShadow {
        filter: drop-shadow(1px 1px 2px rgba(170, 0, 0, 0.5));
      }
      @media screen and (max-width: 600px) {
        #map {
          height: calc(100vh - 140px);
        }
        #searchBox {
          top: 100px;
          left: 5px;
          width: 180px;
        }
        #infoBox {
          width: 220px;
          bottom: 10px;
          right: 5px;
          font-size: 12px;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h2>ì‚°ë¶ˆ í™•ì‚° ì˜ˆì¸¡</h2>
      <p>ì‚°ë¶ˆ ë°œìƒ ì§€ì ê³¼ ë°”ëŒ ì •ë³´ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ë²ˆì§ˆ ë°©í–¥ì„ ì˜ˆì¸¡í•©ë‹ˆë‹¤.</p>
    </header>

    <div id="map"></div>

    <div id="searchBox">
      <label for="addressInput">ì£¼ì†Œ ê²€ìƒ‰</label>
      <input type="text" id="addressInput" placeholder="ì˜ˆ) ì„œìš¸ì—­" />
      <button onclick="handleSearch()">ê²€ìƒ‰</button>
      <button onclick="handleCurrentLocation()">í˜„ì¬ ìœ„ì¹˜</button>
    </div>

    <div id="infoBox">
      <h3>ë°”ëŒ ì •ë³´ ë° 4ë°©ìœ„ í™•ì‚°ë¥ </h3>
      <div id="infoContent"></div>
      <button id="refreshBtn" onclick="handleRefresh()">ìƒˆë¡œê³ ì¹¨</button>
    </div>

    <!-- Leaflet JS -->
    <script src="./leaflet/leaflet.js"></script>
    <script>
      let modelPredictions = [];

      fetch("./predicted_spread.json")
        .then((res) => res.json())
        .then((data) => {
          modelPredictions = data;
          console.log("âœ… Model predictions loaded:", modelPredictions.length);
        });
      // [A] ì§€ë„ ì´ˆê¸°í™”
      const koreaBounds = L.latLngBounds([33, 124], [39.5, 132]);
      const map = L.map("map", {
        zoomControl: false,
        maxBounds: koreaBounds,
        maxBoundsViscosity: 1.0,
      }).setView([36.5, 127.5], 7);

      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        attribution: "&copy; OpenStreetMap contributors",
      }).addTo(map);

      L.control.zoom({ position: "bottomleft" }).addTo(map);

      const spreadLayer = L.layerGroup().addTo(map);
      const infoContent = document.getElementById("infoContent");
      const addressInput = document.getElementById("addressInput");
      let currentLat = null,
        currentLon = null;

      // [B] ë²”ë¡€ ì»¨íŠ¸ë¡¤ ì¶”ê°€ (í•˜ë‹¨ ì˜¤ë¥¸ìª½)
      const legend = L.control({ position: "bottomright" });
      legend.onAdd = function () {
        const div = L.DomUtil.create("div", "legend");
        div.innerHTML = `
                <b>í™•ì‚° ê°•ë„ (6ë‹¨ê³„)</b><br>
                <i style="background: darkred"></i> â‰¥40%<br>
                <i style="background: orangered"></i> 30~40%<br>
                <i style="background: orange"></i> 20~30%<br>
                <i style="background: yellow"></i> 10~20%<br>
                <i style="background: lightyellow"></i> 5~10%<br>
                <i style="background: whitesmoke"></i> 0~5%
              `;
        return div;
      };
      legend.addTo(map);

      // [C] 8ë°©ìœ„ í™•ë¥  ê³„ì‚° í•¨ìˆ˜ (ìµœì†Œ 5% ë¶€ì—¬, ì œê³± ê°ì‡ )
      function calcSpreadProbCustom8(windDir) {
        const fireSpreadDir = (windDir + 180) % 360;
        const sectors = {
          N: 0,
          NE: 45,
          E: 90,
          SE: 135,
          S: 180,
          SW: 225,
          W: 270,
          NW: 315,
        };
        const BASELINE = 0.05;
        let raw = {},
          total = 0;
        for (let dir in sectors) {
          let diff = Math.abs(fireSpreadDir - sectors[dir]);
          if (diff > 180) diff = 360 - diff;
          let linear = 1 - diff / 90;
          if (linear < 0) linear = 0;
          let w = BASELINE + (1 - BASELINE) * Math.pow(linear, 2);
          raw[dir] = w;
          total += w;
        }
        let prob = {};
        for (let d in raw) {
          prob[d] = raw[d] / total;
        }
        return prob;
      }

      // [D] 8ë°©ìœ„ ì„ í˜• ë³´ê°„ í•¨ìˆ˜
      function getInterpolatedProb(angle, prob8) {
        const sectors = [
          { dir: "N", angle: 0 },
          { dir: "NE", angle: 45 },
          { dir: "E", angle: 90 },
          { dir: "SE", angle: 135 },
          { dir: "S", angle: 180 },
          { dir: "SW", angle: 225 },
          { dir: "W", angle: 270 },
          { dir: "NW", angle: 315 },
          { dir: "N", angle: 360 },
        ];
        let lower, upper;
        for (let i = 0; i < sectors.length - 1; i++) {
          if (angle >= sectors[i].angle && angle <= sectors[i + 1].angle) {
            lower = sectors[i];
            upper = sectors[i + 1];
            break;
          }
        }
        if (!lower || !upper) return prob8["N"];
        let t = (angle - lower.angle) / (upper.angle - lower.angle);
        return prob8[lower.dir] * (1 - t) + prob8[upper.dir] * t;
      }

      // [E] ì…€ í™•ë¥  ê³„ì‚° í•¨ìˆ˜
      // í´ë¦­ ì§€ì  â†’ ì…€ ë°©í–¥ì— ë”°ë¥¸ 8ë°©ìœ„ ë³´ê°„ í™•ë¥ ê³¼ ê±°ë¦¬ ê°ì‡ ë¥¼ ì ìš©í•©ë‹ˆë‹¤.
      function computeCellProbability(distanceKm, cellBearing, prob8) {
        const angleProb = getInterpolatedProb(cellBearing, prob8);
        const maxDist = 1 + 4 * angleProb; // 1km ~ 5km
        if (distanceKm > maxDist) return 0;
        return angleProb * Math.pow(1 - distanceKm / maxDist, 2);
      }

      // [F] ìƒ‰ìƒ ë³´ê°„ í•¨ìˆ˜ (6ë‹¨ê³„)
      function getHeatColor(prob) {
        const pct = prob * 100;
        if (pct >= 40) {
          return "darkred";
        } else if (pct >= 30) {
          return "orangered";
        } else if (pct >= 20) {
          return "orange";
        } else if (pct >= 10) {
          return "yellow";
        } else if (pct >= 5) {
          return "lightyellow";
        } else {
          return "whitesmoke";
        }
      }

      // [G] íˆíŠ¸ë§µ ìƒì„± í•¨ìˆ˜ (ê²©ì ê¸°ë°˜, 8ë°©ìœ„ í™•ë¥  ì ìš©)
      // í™•ë¥ ì´ 5% ì´ìƒì¸ ì…€ë§ˆë‹¤, ê²½ê³„ì„ ê³¼ ê·¸ë¦¼ì íš¨ê³¼ë¥¼ í•­ìƒ ì ìš©í•©ë‹ˆë‹¤.
      function drawHeatmap(lat, lon, windDir) {
        const maxDistanceKm = 5;
        const centerLatRad = (lat * Math.PI) / 180;
        const gridSize = 250; // 250m ê²©ì
        const dLat = gridSize / 111000;
        const dLon = gridSize / (111000 * Math.cos(centerLatRad));
        const latRange = maxDistanceKm / 111;
        const lonRange = maxDistanceKm / (111 * Math.cos(centerLatRad));
        const latMin = lat - latRange;
        const latMax = lat + latRange;
        const lonMin = lon - lonRange;
        const lonMax = lon + lonRange;
        // 8ë°©ìœ„ í™•ë¥  ê³„ì‚°
        const prob8 = calcSpreadProbCustom8(windDir);

        for (let cellLat = latMin; cellLat <= latMax; cellLat += dLat) {
          for (let cellLon = lonMin; cellLon <= lonMax; cellLon += dLon) {
            let deltaLat = (cellLat - lat) * 111;
            let deltaLon = (cellLon - lon) * 111 * Math.cos(centerLatRad);
            let distance = Math.sqrt(deltaLat * deltaLat + deltaLon * deltaLon);
            if (distance > maxDistanceKm) continue;

            let bearing = (Math.atan2(deltaLon, deltaLat) * 180) / Math.PI;
            if (bearing < 0) bearing += 360;

            const cellProb = computeCellProbability(distance, bearing, prob8);
            if (cellProb < 0.05) continue;

            const color = getHeatColor(cellProb);
            // ëª¨ë°”ì¼ì—ì„œë„ ì„ ëª…í•˜ê²Œ ë³´ì´ë„ë¡ fillOpacity ì¡°ì • (0.2 ~ 0.9)
            let fillOpacity = 0.3 + 0.7 * cellProb;

            // ëª¨ë“  ì…€ì— ê²½ê³„ì„ ê³¼ ê·¸ë¦¼ì íš¨ê³¼ ì ìš© (weight: 1.5, borderColor = fillColor, className: "highProbShadow")
            let borderWeight = 1.5;
            let borderColor = color;

            let bounds = [
              [cellLat, cellLon],
              [cellLat + dLat, cellLon + dLon],
            ];
            let rect = L.rectangle(bounds, {
              color: borderColor,
              weight: borderWeight,
              fillColor: color,
              fillOpacity: fillOpacity,
              className: "highProbShadow",
            }).addTo(spreadLayer);
            // í„°ì¹˜/í´ë¦­ ì‹œ íŒì—…ìœ¼ë¡œ í™•ì‚° ê°•ë„(%) í‘œì‹œ
            rect.bindPopup((cellProb * 100).toFixed(1) + "%");
            rect.on("click", function () {
              rect.openPopup();
            });
          }
        }
      }

      // [H] destinationPoint í•¨ìˆ˜ (í•„ìš”ì‹œ ì‚¬ìš©)
      function destinationPoint(lat, lon, bearingDeg, distanceKm) {
        const R = 6371;
        const rad = Math.PI / 180;
        const latRad = lat * rad;
        const lonRad = lon * rad;
        const bearing = bearingDeg * rad;
        const dOverR = distanceKm / R;
        const newLat = Math.asin(
          Math.sin(latRad) * Math.cos(dOverR) +
            Math.cos(latRad) * Math.sin(dOverR) * Math.cos(bearing)
        );
        const newLon =
          lonRad +
          Math.atan2(
            Math.sin(bearing) * Math.sin(dOverR) * Math.cos(latRad),
            Math.cos(dOverR) - Math.sin(latRad) * Math.sin(newLat)
          );
        return [newLat / rad, newLon / rad];
      }

      // [I] infoBoxì— 4ë°©ìœ„ í™•ì‚°ë¥  ì •ë³´ í‘œì‹œ í•¨ìˆ˜ (N, E, S, W)
      function buildWindInfoText(windDir, windSpd, prob8) {
        const nPct = (prob8["N"] * 100).toFixed(1);
        const ePct = (prob8["E"] * 100).toFixed(1);
        const sPct = (prob8["S"] * 100).toFixed(1);
        const wPct = (prob8["W"] * 100).toFixed(1);
        return `í’í–¥: ${windDir}Â° / í’ì†: ${windSpd} km/h
      N: ${nPct}%, E: ${ePct}%,
      S: ${sPct}%, W: ${wPct}%`;
      }

      // [J] ì§€ë„ í´ë¦­ ì´ë²¤íŠ¸
      map.on("click", (e) => {
        simulateSpread(e.latlng.lat, e.latlng.lng);
      });
      function isInKorea(lat, lon) {
        return lat >= 33 && lat <= 39.5 && lon >= 124 && lon <= 132;
      }

      // [K] ì£¼ì†Œ ê²€ìƒ‰ í•¨ìˆ˜
      async function handleSearch() {
        const address = addressInput.value.trim();
        if (!address) {
          alert("ì£¼ì†Œë¥¼ ì…ë ¥í•˜ì„¸ìš”");
          return;
        }
        try {
          const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(
            address
          )}`;
          const res = await fetch(url);
          const data = await res.json();
          if (!data.length) {
            alert("í•´ë‹¹ ì£¼ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
            return;
          }
          const lat = parseFloat(data[0].lat);
          const lon = parseFloat(data[0].lon);
          if (!isInKorea(lat, lon)) {
            alert("ëŒ€í•œë¯¼êµ­ ë‚´ ì£¼ì†Œë§Œ ê²€ìƒ‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.");
            return;
          }
          map.setView([lat, lon], 13);
          simulateSpread(lat, lon);
        } catch (err) {
          console.error("ì£¼ì†Œ ê²€ìƒ‰ ì˜¤ë¥˜:", err);
          alert("ì£¼ì†Œ ê²€ìƒ‰ ì¤‘ ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
        }
      }

      // [L] í˜„ì¬ ìœ„ì¹˜ ë²„íŠ¼ í•¨ìˆ˜
      async function handleCurrentLocation() {
        if (!navigator.geolocation) {
          alert("ì´ ë¸Œë¼ìš°ì €ëŠ” í˜„ì¬ ìœ„ì¹˜ë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.");
          return;
        }
        navigator.geolocation.getCurrentPosition(
          async (pos) => {
            const lat = pos.coords.latitude;
            const lon = pos.coords.longitude;
            if (!isInKorea(lat, lon)) {
              alert("í˜„ì¬ ìœ„ì¹˜ê°€ ëŒ€í•œë¯¼êµ­ ì™¸ë¶€ë¡œ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.");
              return;
            }
            try {
              const revUrl = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}`;
              const revRes = await fetch(revUrl);
              const revData = await revRes.json();
              addressInput.value = revData.display_name || "ë‚´ ìœ„ì¹˜";
            } catch (e) {
              console.error("ì—­ì§€ì˜¤ì½”ë”© ì‹¤íŒ¨:", e);
              addressInput.value = "ë‚´ ìœ„ì¹˜(ì£¼ì†Œ í™•ì¸ ì‹¤íŒ¨)";
            }
            map.setView([lat, lon], 13);
            simulateSpread(lat, lon);
          },
          (err) => {
            console.error("Geolocation error:", err);
            alert("í˜„ì¬ ìœ„ì¹˜ë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
          }
        );
      }

      // [M] ìƒˆë¡œê³ ì¹¨ ë²„íŠ¼ í•¨ìˆ˜
      function handleRefresh() {
        if (currentLat === null || currentLon === null) {
          alert("ì•„ì§ ìœ„ì¹˜ê°€ ì§€ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.");
          return;
        }
        simulateSpread(currentLat, currentLon);
      }

      // [N] ë°”ëŒ ë°ì´í„° ì¡°íšŒ ë° ì‹œë®¬ë ˆì´ì…˜ í•¨ìˆ˜
      async function simulateSpread(lat, lon) {
        currentLat = lat;
        currentLon = lon;
        spreadLayer.clearLayers();
        L.marker([lat, lon]).addTo(spreadLayer);
        try {
          const revUrl = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}`;
          const revRes = await fetch(revUrl);
          const revData = await revRes.json();
          addressInput.value = revData.display_name || "ë‚´ ìœ„ì¹˜";
        } catch (e) {
          console.error("ì—­ì§€ì˜¤ì½”ë”© ì‹¤íŒ¨:", e);
        }
        const apiUrl = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current_weather=true`;
        try {
          const res = await fetch(apiUrl);
          if (!res.ok) throw new Error("Open-Meteo API ì‘ë‹µ ì˜¤ë¥˜");
          const data = await res.json();
          if (!data.current_weather) throw new Error("current_weather ì—†ìŒ");

          const windDir = data.current_weather.winddirection;
          const windSpd = data.current_weather.windspeed;
          const probFromWind = calcSpreadProbCustom8(windDir);

          // ğŸ” ê°€ì¥ ê°€ê¹Œìš´ ì˜ˆì¸¡ ìœ„ì¹˜ ì°¾ê¸°
          let closest = null;
          let minDist = Infinity;
          for (const entry of modelPredictions) {
            const dLat = entry.lat - lat;
            const dLon = entry.lon - lon;
            const dist = dLat * dLat + dLon * dLon;
            if (dist < minDist) {
              minDist = dist;
              closest = entry;
            }
          }

          const probFromModel = closest ? closest.predicted_prob : probFromWind;
          const prob8 = blendSpreadProb(probFromWind, probFromModel, 0.7);

          infoContent.textContent = buildWindInfoText(windDir, windSpd, prob8);
          drawHeatmap(lat, lon, windDir, prob8);
        } catch (err) {
          console.error("ì‹œë®¬ë ˆì´ì…˜ ì˜¤ë¥˜:", err);
          infoContent.textContent = "ë°”ëŒ ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.";
        }
      }

      // [O] destinationPoint í•¨ìˆ˜ (í•„ìš”ì‹œ ì‚¬ìš©)
      function destinationPoint(lat, lon, bearingDeg, distanceKm) {
        const R = 6371;
        const rad = Math.PI / 180;
        const latRad = lat * rad;
        const lonRad = lon * rad;
        const bearing = bearingDeg * rad;
        const dOverR = distanceKm / R;
        const newLat = Math.asin(
          Math.sin(latRad) * Math.cos(dOverR) +
            Math.cos(latRad) * Math.sin(dOverR) * Math.cos(bearing)
        );
        const newLon =
          lonRad +
          Math.atan2(
            Math.sin(bearing) * Math.sin(dOverR) * Math.cos(latRad),
            Math.cos(dOverR) - Math.sin(latRad) * Math.sin(newLat)
          );
        return [newLat / rad, newLon / rad];
      }

      // [P] í’í–¥ í™”ì‚´í‘œ ì œê±° (ìš”ì²­ì— ë”°ë¼ í˜¸ì¶œí•˜ì§€ ì•ŠìŒ)

      // [Q] í˜ì´ì§€ ë¡œë“œ ì‹œ í˜„ì¬ ìœ„ì¹˜ë¡œ ì‹œì‘
      window.onload = function () {
        handleCurrentLocation();
      };

      function blendSpreadProb(W, M, alpha = 0.7) {
        const blended = {};
        for (const dir of Object.keys(W)) {
          blended[dir] = alpha * W[dir] + (1 - alpha) * M[dir];
        }
        return blended;
      }
    </script>
  </body>
</html>
