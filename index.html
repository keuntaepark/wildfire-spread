<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <title>산불 확산 예측</title>
    <!-- 모바일 대응 -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- 로컬 Leaflet CSS -->
    <link rel="stylesheet" href="./leaflet/leaflet.css" />
    <style>
      /* 기본 리셋 */
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
      }
      body {
        background-color: #f4f4f4;
        color: #333;
      }
      /* 상단 헤더 */
      header {
        background: #fff;
        padding: 8px 16px;
        border-bottom: 1px solid #ccc;
        position: relative;
      }
      header h2 {
        margin: 0;
        font-size: 18px;
      }
      header p {
        margin: 4px 0 0;
        font-size: 13px;
        color: #666;
      }
      /* PKT 표시 (우측 상단) */
      #pktSignature {
        position: absolute;
        top: 10px;
        right: 10px;
        font-size: 12px;
        color: #aaa;
      }
      /* 지도 영역 */
      #map {
        width: 100%;
        height: calc(100vh - 90px);
      }
      /* 왼쪽 상단: 주소 검색 & 현재 위치 */
      #searchBox {
        position: absolute;
        top: 70px;
        left: 10px;
        z-index: 9999;
        width: 220px;
        background: #fff;
        border-radius: 6px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
        padding: 8px;
        border: 1px solid #eee;
      }
      #searchBox label {
        font-size: 14px;
        font-weight: 600;
        margin-bottom: 6px;
        display: block;
      }
      #searchBox input {
        width: 100%;
        padding: 6px;
        font-size: 14px;
        margin-bottom: 8px;
        border: 1px solid #ccc;
        border-radius: 4px;
      }
      #searchBox button {
        width: 100%;
        padding: 8px;
        margin-bottom: 6px;
        font-size: 14px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        background: #ff6b6b;
        color: #fff;
      }
      #searchBox button:hover {
        background: #ff4c4c;
      }
      /* 오른쪽 하단: 바람 정보 패널 */
      #infoBox {
        position: absolute;
        bottom: 10px;
        right: 10px;
        z-index: 9999;
        width: 200px;
        background: #fff;
        border-radius: 6px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
        padding: 8px;
        border: 1px solid #eee;
        font-size: 13px;
        line-height: 1.3;
        white-space: pre-wrap;
      }
      #infoBox h3 {
        margin-bottom: 4px;
        font-size: 14px;
        font-weight: 600;
      }
      /* 새로고침 버튼 */
      #refreshBtn {
        display: block;
        width: 100%;
        margin-top: 8px;
        padding: 6px;
        font-size: 12px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        background: #777;
        color: #fff;
        text-align: center;
      }
      #refreshBtn:hover {
        background: #555;
      }
      /* 반응형(모바일) */
      @media screen and (max-width: 600px) {
        #map {
          height: calc(100vh - 140px);
        }
        #searchBox {
          top: 100px;
          left: 5px;
          width: 180px;
        }
        #infoBox {
          width: 180px;
          bottom: 70px;
          right: 5px;
          font-size: 10px;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h2>산불 확산 예측</h2>
      <p>산불 발생 지점과 바람 정보를 기준으로 번질 방향을 예측합니다.</p>
      <div id="pktSignature">PKT</div>
    </header>

    <!-- 지도 영역 -->
    <div id="map"></div>

    <!-- 주소 검색/현재 위치 박스 -->
    <div id="searchBox">
      <label for="addressInput">주소 검색</label>
      <input type="text" id="addressInput" placeholder="예) 서울역" />
      <button onclick="handleSearch()">검색</button>
      <button onclick="handleCurrentLocation()">현재 위치</button>
    </div>

    <!-- 바람 정보 박스 (오른쪽 하단) -->
    <div id="infoBox">
      <h3>바람 정보</h3>
      <div id="infoContent">- 바람 정보가 여기 표시됩니다 -</div>
      <button id="refreshBtn" onclick="handleRefresh()">새로고침</button>
    </div>

    <!-- 로컬 Leaflet JS -->
    <script src="./leaflet/leaflet.js"></script>
    <script>
      // -----------------------
      // 유틸리티: 간단한 확산 확률 계산 (카드날 기준 룰)
      // 바람이 불어오는 방향을 기준으로, 실제 산불은 그 반대 방향으로 번지므로,
      // fireSpreadDir = (windDir + 180) mod 360
      // 룰: 주 방향 60, 양옆 20, 반대편 10 (총 110, 정규화)
      function calcSpreadProbCustom(windDir) {
        let spreadDir = (windDir + 180) % 360;
        const cardinals = { N: 0, E: 90, S: 180, W: 270 };
        let diffs = {};
        for (let d in cardinals) {
          let diff = Math.abs(spreadDir - cardinals[d]);
          if (diff > 180) diff = 360 - diff;
          diffs[d] = diff;
        }
        let mainDir = Object.keys(diffs).reduce((a, b) =>
          diffs[a] < diffs[b] ? a : b
        );
        const order = ["N", "E", "S", "W"];
        let mainIndex = order.indexOf(mainDir);
        let adj1 = order[(mainIndex + 1) % 4];
        let adj2 = order[(mainIndex + 3) % 4];
        let opp = order[(mainIndex + 2) % 4];
        let raw = {};
        raw[mainDir] = 60;
        raw[adj1] = 20;
        raw[adj2] = 20;
        raw[opp] = 10;
        let sum = 60 + 20 + 20 + 10; // 110
        let prob = {};
        for (let d in raw) {
          prob[d] = raw[d] / sum;
        }
        return prob;
      }

      // -----------------------
      // 화살표 마커 그리기 (주 방향 표시)
      function drawArrowMarker(lat, lon, windDir) {
        let fireSpreadDir = (windDir + 180) % 360;
        // L.divIcon을 사용해 간단한 SVG 화살표 표시 (HTML 문자 ▲ 사용)
        let arrowIcon = L.divIcon({
          html: `<div style="transform: rotate(${fireSpreadDir}deg); font-size: 32px; line-height: 32px; color: red;">&#9650;</div>`,
          className: "",
          iconSize: [32, 32],
          iconAnchor: [16, 16],
        });
        L.marker([lat, lon], { icon: arrowIcon }).addTo(spreadLayer);
      }

      // -----------------------
      // 지도와 초기 위치
      // 대한민국 범위 설정
      const koreaBounds = L.latLngBounds(
        L.latLng(33.0, 124.0),
        L.latLng(39.5, 132.0)
      );
      // 지도 초기화 (현재 위치를 기준으로 시작할 예정)
      const map = L.map("map", {
        zoomControl: false,
        maxBounds: koreaBounds,
        maxBoundsViscosity: 1.0,
      }).setView([36.5, 127.5], 7);
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        attribution: "&copy; OpenStreetMap contributors",
      }).addTo(map);
      L.control.zoom({ position: "bottomleft" }).addTo(map);
      const spreadLayer = L.layerGroup().addTo(map);
      const infoContent = document.getElementById("infoContent");
      const addressInput = document.getElementById("addressInput");
      let currentLat = null,
        currentLon = null;

      // -----------------------
      // 현재 위치 자동 설정 (페이지 로드 시)
      function initCurrentLocation() {
        if (!navigator.geolocation) {
          alert("이 브라우저는 현재 위치를 지원하지 않습니다.");
          return;
        }
        navigator.geolocation.getCurrentPosition(
          (pos) => {
            const lat = pos.coords.latitude;
            const lon = pos.coords.longitude;
            if (!isInKorea(lat, lon)) {
              alert("현재 위치가 대한민국 외부로 감지되었습니다.");
              return;
            }
            map.setView([lat, lon], 13);
            simulateSpread(lat, lon);
          },
          (err) => {
            console.error("Geolocation error:", err);
            alert("현재 위치를 가져올 수 없습니다.");
          }
        );
      }

      // -----------------------
      // 지도 클릭 이벤트: 선택한 위치 기준 시뮬레이션
      map.on("click", (e) => {
        simulateSpread(e.latlng.lat, e.latlng.lng);
      });

      function isInKorea(lat, lon) {
        return lat >= 33.0 && lat <= 39.5 && lon >= 124.0 && lon <= 132.0;
      }

      // -----------------------
      // 주소 검색 함수
      async function handleSearch() {
        const address = addressInput.value.trim();
        if (!address) {
          alert("주소를 입력하세요");
          return;
        }
        try {
          const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(
            address
          )}`;
          const res = await fetch(url);
          const data = await res.json();
          if (!data.length) {
            alert("해당 주소를 찾을 수 없습니다.");
            return;
          }
          const lat = parseFloat(data[0].lat);
          const lon = parseFloat(data[0].lon);
          if (!isInKorea(lat, lon)) {
            alert("대한민국 내 주소만 검색할 수 있습니다.");
            return;
          }
          map.setView([lat, lon], 13);
          simulateSpread(lat, lon);
        } catch (err) {
          console.error("주소 검색 오류:", err);
          alert("주소 검색 중 문제가 발생했습니다.");
        }
      }

      // -----------------------
      // 현재 위치 버튼 함수
      async function handleCurrentLocation() {
        if (!navigator.geolocation) {
          alert("이 브라우저는 현재 위치를 지원하지 않습니다.");
          return;
        }
        navigator.geolocation.getCurrentPosition(
          async (pos) => {
            const lat = pos.coords.latitude;
            const lon = pos.coords.longitude;
            if (!isInKorea(lat, lon)) {
              alert("현재 위치가 대한민국 외부로 감지되었습니다.");
              return;
            }
            try {
              const revUrl = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}`;
              const revRes = await fetch(revUrl);
              const revData = await revRes.json();
              addressInput.value = revData.display_name || "내 위치";
            } catch (e) {
              console.error("역지오코딩 실패:", e);
              addressInput.value = "내 위치(주소 확인 실패)";
            }
            map.setView([lat, lon], 13);
            simulateSpread(lat, lon);
          },
          (err) => {
            console.error("Geolocation error:", err);
            alert("현재 위치를 가져올 수 없습니다.");
          }
        );
      }

      // -----------------------
      // 새로고침 버튼 함수
      function handleRefresh() {
        if (currentLat === null || currentLon === null) {
          alert("아직 위치가 지정되지 않았습니다.");
          return;
        }
        simulateSpread(currentLat, currentLon);
      }

      // -----------------------
      // 바람 데이터 조회 및 확산 시뮬레이션 함수
      async function simulateSpread(lat, lon) {
        currentLat = lat;
        currentLon = lon;
        spreadLayer.clearLayers();
        L.marker([lat, lon]).addTo(spreadLayer);
        try {
          const revUrl = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}`;
          const revRes = await fetch(revUrl);
          const revData = await revRes.json();
          addressInput.value = revData.display_name || "내 위치";
        } catch (e) {
          console.error("역지오코딩 실패:", e);
        }
        const apiUrl = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current_weather=true`;
        try {
          const res = await fetch(apiUrl);
          if (!res.ok) throw new Error("Open-Meteo API 응답 오류");
          const data = await res.json();
          if (!data.current_weather) throw new Error("current_weather 없음");
          const windDir = data.current_weather.winddirection;
          const windSpd = data.current_weather.windspeed;
          // 사용자에게 간단한 정보 표시
          const isMobile = window.innerWidth < 600;
          if (isMobile) {
            infoContent.textContent = buildCompactText(
              calcSpreadProbCustom(windDir)
            );
          } else {
            infoContent.textContent = buildFullText(
              lat,
              lon,
              windDir,
              windSpd,
              calcSpreadProbCustom(windDir)
            );
          }
          // 시각화: 보정 확률 기반 부채꼴과 화살표 추가
          drawGradientSectors(lat, lon, calcSpreadProbCustom(windDir));
          drawArrowMarker(lat, lon, windDir);
        } catch (err) {
          console.error("시뮬레이션 오류:", err);
          infoContent.textContent = "바람 정보를 불러오지 못했습니다.";
        }
      }

      // -----------------------
      // 전체 정보(PC) 빌드 함수
      function buildFullText(lat, lon, windDir, windSpd, prob) {
        let txt = `위도: ${lat.toFixed(4)}, 경도: ${lon.toFixed(4)}\n`;
        txt += `풍향: ${windDir}° (불어오는 각도)\n`;
        txt += `풍속: ${windSpd} km/h\n\n`;
        txt += "[확산 확률]\n";
        txt += `북(N): ${(prob.N * 100).toFixed(1)}%\n`;
        txt += `동(E): ${(prob.E * 100).toFixed(1)}%\n`;
        txt += `남(S): ${(prob.S * 100).toFixed(1)}%\n`;
        txt += `서(W): ${(prob.W * 100).toFixed(1)}%\n`;
        return txt;
      }

      // -----------------------
      // 간단 정보(모바일) 빌드 함수
      function buildCompactText(prob) {
        let txt = "[확산 확률]\n";
        txt += `N: ${(prob.N * 100).toFixed(1)}%\n`;
        txt += `E: ${(prob.E * 100).toFixed(1)}%\n`;
        txt += `S: ${(prob.S * 100).toFixed(1)}%\n`;
        txt += `W: ${(prob.W * 100).toFixed(1)}%\n`;
        return txt;
      }

      // -----------------------
      // 등고선 부채꼴 시각화 (기존 그라데이션 방식)
      function drawGradientSectors(lat, lon, prob) {
        const cardinalAngles = { N: 0, E: 90, S: 180, W: 270 };
        function interpolateColor(c1, c2, t) {
          const r = Math.round(c1[0] + (c2[0] - c1[0]) * t);
          const g = Math.round(c1[1] + (c2[1] - c1[1]) * t);
          const b = Math.round(c1[2] + (c2[2] - c1[2]) * t);
          return [r, g, b];
        }
        const red = [255, 0, 0];
        const green = [0, 128, 0];
        for (const dir in cardinalAngles) {
          const p = prob[dir];
          if (p < 0.001) continue;
          const centerAngle = cardinalAngles[dir];
          const halfAngle = 15;
          const maxRadiusKm = 4 * p;
          const steps = 5;
          for (let i = 0; i < steps; i++) {
            const r1 = (maxRadiusKm * i) / steps;
            const r2 = (maxRadiusKm * (i + 1)) / steps;
            const t = r2 / maxRadiusKm;
            const [R, G, B] = interpolateColor(red, green, t);
            const alpha = 0.2 + 0.8 * p;
            const fillColor = `rgba(${R},${G},${B},${alpha})`;
            const ringCoords = buildAnnulusSector(
              lat,
              lon,
              centerAngle,
              halfAngle,
              r1,
              r2
            );
            L.polygon(ringCoords, {
              color: `rgb(${R},${G},${B})`,
              weight: 1,
              fillColor: fillColor,
              fillOpacity: 1.0,
            }).addTo(spreadLayer);
          }
        }
      }

      // -----------------------
      // "고리(annulus)" 섹터 생성 함수
      function buildAnnulusSector(
        lat,
        lon,
        centerAngle,
        halfAngle,
        rInner,
        rOuter
      ) {
        const coords = [];
        const step = 3;
        const start = centerAngle - halfAngle;
        const end = centerAngle + halfAngle;
        for (let bearing = start; bearing <= end; bearing += step) {
          coords.push(destinationPoint(lat, lon, bearing, rOuter));
        }
        coords.push(destinationPoint(lat, lon, end, rOuter));
        for (let bearing = end; bearing >= start; bearing -= step) {
          coords.push(destinationPoint(lat, lon, bearing, rInner));
        }
        coords.push(destinationPoint(lat, lon, start, rInner));
        return coords;
      }

      // -----------------------
      // 확산 확률 계산 함수 (간단 룰: 바람 부는 방향 기준 60/20/20/10, 정규화)
      function calcSpreadProbCustom(windDir) {
        let spreadDir = (windDir + 180) % 360;
        const cardinals = { N: 0, E: 90, S: 180, W: 270 };
        let diffs = {};
        for (let d in cardinals) {
          let diff = Math.abs(spreadDir - cardinals[d]);
          if (diff > 180) diff = 360 - diff;
          diffs[d] = diff;
        }
        let mainDir = Object.keys(diffs).reduce((a, b) =>
          diffs[a] < diffs[b] ? a : b
        );
        const order = ["N", "E", "S", "W"];
        let mainIndex = order.indexOf(mainDir);
        let adj1 = order[(mainIndex + 1) % 4];
        let adj2 = order[(mainIndex + 3) % 4];
        let opp = order[(mainIndex + 2) % 4];
        let raw = {};
        raw[mainDir] = 60;
        raw[adj1] = 20;
        raw[adj2] = 20;
        raw[opp] = 10;
        let sum = 60 + 20 + 20 + 10; // 110
        let prob = {};
        for (let d in raw) {
          prob[d] = raw[d] / sum;
        }
        return prob;
      }

      // -----------------------
      // 화살표 마커 그리기 (주 확산 방향 표시)
      function drawArrowMarker(lat, lon, windDir) {
        let fireSpreadDir = (windDir + 180) % 360;
        let arrowIcon = L.divIcon({
          html: `<div style="transform: rotate(${fireSpreadDir}deg); font-size: 32px; color: red;">&#9650;</div>`,
          className: "arrow-icon",
          iconSize: [32, 32],
          iconAnchor: [16, 16],
        });
        L.marker([lat, lon], { icon: arrowIcon }).addTo(spreadLayer);
      }

      // -----------------------
      // 페이지 로드 시 현재 위치로 시작
      window.onload = function () {
        handleCurrentLocation();
      };
    </script>
  </body>
</html>
